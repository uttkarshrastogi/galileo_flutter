// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'dart_types.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_url_source`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Initialize the Galileo Flutter plugin with FFI pointer for irondash
Future<void> galileoFlutterInit({required PlatformInt64 ffiPtr}) =>
    RustLib.instance.api.crateApiApiGalileoFlutterInit(ffiPtr: ffiPtr);

Future<CreateNewSessionResponse> createNewMapSession({
  required PlatformInt64 engineHandle,
  required MapInitConfig config,
}) => RustLib.instance.api.crateApiApiCreateNewMapSession(
  engineHandle: engineHandle,
  config: config,
);

/// Triggers a map update and re-render.
Future<void> requestMapRedraw({required int sessionId}) =>
    RustLib.instance.api.crateApiApiRequestMapRedraw(sessionId: sessionId);

/// Marks the session as alive (called periodically from Flutter)
Future<void> markSessionAlive({required int sessionId}) =>
    RustLib.instance.api.crateApiApiMarkSessionAlive(sessionId: sessionId);

/// Destroys all streams for a given engine
Future<void> destroyAllEngineSessions({required PlatformInt64 engineId}) =>
    RustLib.instance.api.crateApiApiDestroyAllEngineSessions(
      engineId: engineId,
    );

/// Destroys a specific session
Future<void> destroySession({required int sessionId}) =>
    RustLib.instance.api.crateApiApiDestroySession(sessionId: sessionId);

/// Adds a layer to a session
Future<void> addSessionLayer({
  required int sessionId,
  required LayerConfig layerConfig,
}) => RustLib.instance.api.crateApiApiAddSessionLayer(
  sessionId: sessionId,
  layerConfig: layerConfig,
);

Future<MapViewport?> getMapViewport({required int sessionId}) =>
    RustLib.instance.api.crateApiApiGetMapViewport(sessionId: sessionId);

Future<void> handleEventForSession({
  required int sessionId,
  required UserEvent event,
}) => RustLib.instance.api.crateApiApiHandleEventForSession(
  sessionId: sessionId,
  event: event,
);

Future<void> resizeSession({
  required int sessionId,
  required MapSize newSize,
}) => RustLib.instance.api.crateApiApiResizeSession(
  sessionId: sessionId,
  newSize: newSize,
);

class CreateNewSessionResponse {
  final int sessionId;
  final PlatformInt64 textureId;

  const CreateNewSessionResponse({
    required this.sessionId,
    required this.textureId,
  });

  @override
  int get hashCode => sessionId.hashCode ^ textureId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CreateNewSessionResponse &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          textureId == other.textureId;
}
